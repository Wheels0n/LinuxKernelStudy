# 서론

임베디드분야에도 지원하기 위해 리눅스 커널을 공부하고자한다. 주로 참조한 건 '디버깅을 통해 배우는 리눅스  
커널의 구조와 원리'이다. 리눅스 첫 버전이 1991년도에 나왔으니 그 방대한 코드를 나같은 초짜가 효율적으로  
학습할 수 있을 리는 없다. 이 책을 주축으로 더 알고 싶은 내용은 관련 블로그나 소스코드로 보충하겠다.
~~이렇게 문서로 정리 안하니까 다시 책읽기 겁나기도 하다.~~

커널 버전은 4.19를 살펴 볼것이다.무

## 왜 배울까?

1. 임베디드 리눅스 혹은 BSP(Board Support Package) 개발자로 디바이스 드라이버 개발을 한다치자. 그런데  
   이 디바이스 드라이버는 커널 함수를 호출하는 방식으로 구현돼 있다.

2. 리눅스 표준 함수를 호출하면 시스템 콜을 통해 실제 커널이 동작한다. 리눅스 시스템 프로그램의 세부 동작  
   원리를 파악 할 수 있다.

3. OS의 핵심원리를 소스코드 분석을 통해 배울 수 있다.

4. 파일 시스템, 메모리 관리, 네트워크 ,이더넷 등의 기술들은 커널에서 소스코드로 만날 수 있다.

5. 데스크톱 PC의 경우 WindowNT계열이 거의 독점하나 모바일로만 가도 유닉스 계열(리눅스, IOS)이 지배한다.

## 리눅스의 역사

### 유닉스의 탄생

리눅스의 모태가 유닉스라서 유닉스를 먼저 살펴 봐야한다. 컴퓨터가 발명된 후 컴퓨터는 한 가지 프로그램만 실행  
했었다. 시간이 흘러 1개이상의 프로그램을 실행할 수 있을 정도로 컴퓨팅 파워가 쎼졌다. 이때 세로 나오는 SW가  
유닉스의 모태가 된 '멀틱스' 운영체제이다. 1965년 MIT, AT&T 벨 연구소, 제네럴 일렉트릭 소속 개발자들이 모여  
Multics라는 OS를 개발을 하기 시작했다. 이 OS는 '멀티태스킹'을 지원하는 것이 목표였다. 허나 이는 실패 했고  
 해당 프로젝트에 투입 되었던 개바잘자들이 지속적으로 OS 연구에 몰두한다. 새 OS는 '멀티태스킹'과 '멀티유저'를  
지원했고 이것이 바로 UNIX이다.

허나 유닉스는 어셈블리어를 사용해서 구현되어서 호환성이 없었고 다른 CPU아키텍쳐에 맞게 어셈블리 명령어를 바꾸는  
건 매우 고된 작업이 었을 것이다. 이 문제를 해결하고자 데니스 리치는 C언어를 개발 하여 새 버전의 유닉스를 C로  
작성 하였다.

### 유닉스 유료화와 GNU 설립

AT&T가 거대 기업이 되어 미국의 졸업생들이 해당 회사로 몰려들었고 미국도 AT&T에 의존적이게 되었다. 이 상황해서  
반독점 소송을 당하여 패소하였고. 법원 명령에 따라 회사는 7개로 나누어 졌고 컴퓨터 사업에서 철수 할 수 밖에 없어  
졌다. 결국 유닉스가 필요 없어진 AT&T는 유닉스는 팔게 되었다.(이때 여러 변종들이 생겨났고 유닉스에 대한 표준을
맞춰 보자하여 POSIX 규격이 만들어 졌다.) 허나 유닉스를 구매한 컴퓨터 업체의 개발자들만 소스코드를 볼 수 있게  
되었고 이에 대한 반발로 무료 버전의 유닉스를 개발하자는 목표로 다음과 같은 단체를 설립한다.

GNU(GNU is Not UNIX)

GNU라는 단체가 FSF(FreeSoftwareFoundation)재단을 설립하면서 무료 유닉스 개발에 착수한다. 리처드 스톨만을 중심으로,
시간이 흘러 유닉스 유틸리티는 어느 정도 완성했지만 유닉스 커널을 재대로 만들수가 없어서 작업이 정체된다.

### BSD 유닉스 소송

GNU에서만 유닉스 개발을 시도한게 아니였다. UC버클리의 BSD(Berkely Software Distribution)개발자들이 기존  
유닉스 코드를 다시 작성하여 Net/1,2를 무료로 배포했다. 허나 AT&T에게 저작권 패소로 BSD유닉스 개발도 정체된다.

### 리눅스 토발즈의 등장

1991년 당시 헬싱키 대학에 재학중이던 리누스 토발즈가 GNU시스템에 적합한 커널을 어느 정도 완성하여 comp.os.minix라는
뉴스그룹에 GNU 무료 OS개발중임을 알렸다. 초기 0.01은 정말 기본 커널 기능만 지원했다. 0.02는 BASH와 GCC정도만 실행  
가능 했다. 이듬해 3월 0.95로 버전이 갱신되었다.

그 당시 FSF단체는 Hurd를 GNU 커널로 개발중이였으나 진척이 없었고 리눅스 토발즈가 만든 유닉스 커널을 GNU커널로 채탁하기로 한다.
이 과정에서 탄생한 것이 리눅스이며, 기존 GNU유틸리티와 커널이 결합해 GNU는 완성된 구조를 이루게 되었다.

## 임베디드 리눅스 개발 단체

1. 리눅스 커널 커뮤니티
   우리가 접하는 대부분의 리눅스 커널 코드는 리눅스 커널 커뮤니티에서 만들어진다. 보통 2주 간격으로 그렉 크로아 하트만이라는  
   개발자가 전 세계 개발자들에게 패치 반영 사실을 통지한다.
2. CPU 벤더(ARM, 인텔, IBM)
   시스템 콜, 익셉션, 컨텍스트 스위칭 같은 커널의 핵심 기능은 CPU마다 구현 방식이 다르며 서로 다른 어셈블리 코드로 구현돼 있다.
3. SoC 벤더(브로드컴, 삼성전자, 퀄컴, 인텔, 미디어텍, 엔비디아 등)
   System_On_Chip은 하나의 컴퓨터 또는 다른 전자 시스템의 모든 구성요소를 통합한 집적회로를 뜻한다. 이들은 먼저 리눅스 커널 버전  
   을 선택하고 CPU 벤더로 부터 툴체인을 받아 자신의 SoC스펙에 맞게 커널을 수정하거나 드라이버를 추가한다.
4. 보드 벤더 및 OEM
   SoC가 릴리스한 리눅스 커널코드를 받아 제품스펙과 시나리오에 맞게 제품을 개발한다. 보드 벤더는 라즈베리 파이재단과 같은 업체이고  
   OEM은 삼성전자, LG전자 같이 상용 제품을 개발하는 업체를 뜻한다. 많은 개발자들은 이단계에 종사한다.

## 알아야 할 지식

- 디바이스 드라이버 : 시나리오와 제어하는 HW는 다양하지만 적어도 아래 것들을 알아야한다.

  - 인터럽트 핸들러 함수와 인터럽트 처리 방식
  - 디바이스 파일로 open/read/write연산에 대한 함수 등록 방법
  - 디바이스 트리를 읽어 디바이스 속성을 저장하는 방식

- 리눅스 커널 : 디바이스 드라이버는 커널에서 제공하는 함수로 구성되어 있어 자연히 분석할 수 밖에 없다.
- CPU 아키텍쳐 : 커널의 핵심 개념들은 대부분은 어셈블리 코드로 구현 되어있는데 핵심동장이 CPU아키텍쳐와 연관된  
  부분이 많기 떄문이다. 그래서 커널을 좀 더 깊게 알고자 하는 분들은 CPU 아키텍쳐(x86, ARM)에 대해 다음과 같은 내용을  
  알아야한다.
  - 어셈블리어
  - 익셉션 발생원리와 익셉션 벡터의 세부 동작
  - 함수 호출 규약
- 빌드 스크립트와 Git : 다른 업체가 개발한 드라이버나 응용프로그램을 현재 사용중인 소스트리에 추가 해야할 떄가 있다.  
  이떄 빌드 스크립트와 빌드 구조를 파악하면 일이 편하다. 또한 대부분의 개발자들이 수정한 코드는 Git명령어를 사용한 패치와  
  포맷으로 관리된다.
